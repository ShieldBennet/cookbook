/**
 * 一句话表述: 在运行时绑定对象的行为的扩展
 * 构成: 基类,继承基类的抽象组件类,继承基类的抽象装饰器,
 * 具体组件类,具体装饰器
 * 对比:
 *  继承: 替代品,更加体现了单一职责原则,
 *       且组件与行为的扩展的组合是动态的,所以更加灵活,
 *       如果不需要动态组合,直接用继承即可
*   bridge-pattern:
 *       相同: 都通过动态组合的扩展了灵活性
 *       不同: bridge是继承树和继承树的组合,
 *            decorator是行为于行为扩展的组合
 *  proxy-pattern.md:
 *       相关: 对原有类行为进行扩展
 *       不同:
 *            能力的不同:
 *                行为扩展与被扩展(代理)对象组合的动态性,
 *                proxy-pattern的组合过程是在编译时进行的
 *                而decorator-pattern组合过程是在运行时进行的(只要是组件基类的子类就可以了),
 *                并且多个功能扩展(装饰器)可以叠加
 *            语义不同:
 *                代理注重于行为的控制/底层实现隔离
 *                装饰器注重于功能的扩展
 *
 * 场景辨析:
 *  1. 直接使用继承 -- 如果行为的扩展不需要动态性
 *  2. 使用proxy -- 语义上是进行控制和隔离
 * */
