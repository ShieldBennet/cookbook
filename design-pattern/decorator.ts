/**
 * 一句话表述: 在运行时修改对象的行为
 * 构成: 基类,继承基类的抽象组件类,继承基类的抽象装饰器,
 * 具体组件类,具体装饰器
 * 对比:
 *  继承: 替代品,更加体现了单一职责原则,
 *       且组件与行为的扩展的组合是动态的,所以更加灵活
*   bridge-pattern:
 *       相同: 都通过动态组合的扩展了灵活性
 *       不同: bridge是继承树和继承树的组合,
 *            decorator是行为于行为扩展的组合
 *  proxy-pattern:
 *       相关: 对原有类行为进行扩展
 *       不同: 行为扩展与被扩展(代理)对象组合的动态性,
 *            proxy-pattern的组合过程是在编译时进行的
 *            而decorator-pattern在使用了抽象装饰器的情况下
 *            组合过程是在运行时进行的(只要是组件基类的子类就可以了)
 * 使用场景:
 *  1. 扩展基类的单独一个行为(直接声明具体的装饰器,仅为了更好地体现单一原则);更进一步 --
 *  2. 如果组件与行为的扩展需要是动态的,那么更进一步地使用抽象装饰器以扩展其组合的灵活性
 * */
